[
{
	"uri": "https://docs.yodiwo.com/doc/platform/",
	"title": "Platform",
	"tags": [],
	"description": "",
	"content": "Cyan makes the life of IoT developers easier, by offering a graph based IoT application development and deployment environment, which allows dispersed network devices of diverse technologies to be seamlessly connected with analytics, storage systems, mobile and web applications. Imaging doing all these via a Graphical User Interface.\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/integrators/direct-connection/using-restful-http-requests/",
	"title": "Using RESTful HTTP requests",
	"tags": [],
	"description": "",
	"content": " Any entity can send HTTPS requests towards cyan and if a proper graph exists, the requests will trigger it and have it executed.\nAPI keys for REST Authentication happens via the use of API keys, created by the user in Cyan’s User Profile Manager:\nEach created API key is globally unique, tied to the account of user that created it, and can be individually enabled and disabled or have its quota tracked and/or enforced.\nBasic HTTP requests towards Alcyone HTTPS requests towards Alcyone must follow the following URL convention:\n[https://cyan.yodiwo.com/hooks/restin//]\nUse of a valid API key is mandatory, otherwise there will be an immediate 403 – Forbidden response.\nThe subpath definition is optional and can be used to easily disambiguate between requests (explained later in this section).\nData can be sent either as URL parameters or within the HTTP Request’s body, in JSON or x-www-form-url encoded key-value pairs.\nCurrently allowed methods are GET and POST.\nAll requests with valid API keys will reach Alcyone and trigger graphs through the following block:\nWhen creating a graph with the REST IN block the user must set the block’s configuration to match the intended and expected HTTPS request from the device.\nThe expected method must be chosen.\nA subpath may beset as well although it’s not mandatory. If set, it acts as a filter and only HTTP requests that have a  suffix matching it will trigger the block. If not set, all valid requests will trigger the block and their subpath suffix will be output on the “URL SUBPATH” output. This can then be driven to:\n value mapping block (static dictionary):   key-value store block (run-time dictionary):   a database query to extract a further runtime decision on how to handle the request:  The rest of the configuration parameters are optional and will be presented shortly.\nUpon sending a valid HTTPS request from a device, the graph will be triggered by the REST IN block(s) whose parameters match the request.\nThe URL subpath will be then provided as the value of the first port, while either of the other two ports will provide the request’s data, depending on how they were sent(key-value form encoded pairs or raw JSON).\nSo a final graph of the simplest case of “take values from a sensor and store them to a DB” could be:\nWhen a sensor device has data to send, it can use an API key and send the appropriate HTTPS POST request to Yodiwo. It will trigger the graph, its JSON data will get deserialized, an SQL query constructed out of the values and then fed to the ‘Query’ port of the MYSQL block.\nHTTP Requests via graph logic Let’s extend this so that the returned HTTP Response provides info about whether the SQL insert operation succeeded or not:\nThe operation remains the same until the DB query result is fed into a VALUE MAPPING block (it could be a triggered constant instead), for example converting status True to 200 and anything else to 406. From there the integer status code can be fed to and trigger the REST IN RESPONSE block for the final HTTP response to the original request.\nThe only thing that needs to change is to configure the REST IN block to not automatically reply with 200 OK to incoming requests but instead produce responses through the graph.\nFor this we set the ‘Send custom response’ switch to ON and set a unique Group ID (any integer number) that will be matched to the configuration of the REST IN RESPONSE block:\nHTTP Requests from Alcyone So far we’ve been receiving sensor-type events into Alcyone. We can also use the HTTP OUT block for a return path, to send out events towards external entities.\nThis can be used to:\n extend Alcyone by sending requests to other system components, connect to 3rd party services, or just send normal events to edge devices that have implemented an HTTP(s) server  The block receives the body of the message as input; the rest of the parameters are configured via the inspector area where the user specifies:\n  URL; http:// or https:// can be used for non-secure or secure connections   HTTP method; GET, POST, PUT currently supported Headers to add Data format; currently supported: JSON, form data, SOAP, XML, raw text   "
},
{
	"uri": "https://docs.yodiwo.com/doc/wisper/",
	"title": "Wisper",
	"tags": [],
	"description": "",
	"content": "Put wisper overview here\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/",
	"title": "Yodiwo APIs",
	"tags": [],
	"description": "",
	"content": "Insert APIs overview here\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/integrators/",
	"title": "Integrators",
	"tags": [],
	"description": "",
	"content": "The goal of IoT System Integrators is to find optimal solutions for creating IoT Applications, getting data in and out of cloud platforms, executing Logic on this data which drives and affects actuators.\nHence it is important to discuss connectivity for edge devices while also providing info about how logic is executed For Yodiwo\u0026rsquo;s Alcyone IoT platform, there are two main ways to achieve edge nodes to/from platform connectivity: (though each can be further subdivided into more options)\n via the Plegma API, via pairing Nodes to a Yodiwo account and presenting Things to Cyan directly, via the use of pre-existing communication-enabling blocks and API Keys tied to a Yodiwo account  Both will be thoroughly analysed in the next sections.\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/platform/interconnection-concepts-and-topology/",
	"title": "Interconnection Concepts and Topology",
	"tags": [],
	"description": "",
	"content": " Introduction An abstract block diagram of the platform’s components and logical interconnections is shown here:\nThe following block diagram shows the various entities that make up the Yodiwo ecosystem in more detail:\nIt can be summarized as follows:\n YCP (Alcyone) which includes:  one or more backend workers API frontends which Nodes connect to using avariety of industry standard protocols the UI frontend  Yodiwo Nodes, which communicate with Alcyone via the open Plegma API. Nodes are thoroughly analyzed in this document. In short they may be:  Fog Gateway Nodes (Wisper) Single Nodes Proxies to 3rd party ecosystems, bridging them to Alcyone  UI Clients  currently, this is Cyan, and it uses a combination of REST, AJAX and Web Socket requests to talk to Yodiwo front end servers. Frontend servers use an open API, “Warlock”, to talk to assigned Back end Workers. The same API can be be 3rd parties to bypass Cyan and implement a different UI client, not necessarily web-based, or even avoid a UI and configure / use the platform via code this API can be encapsulated inside Plegma and available to paired Nodes with the proper permissions, for them to control User context through external apps  Message brokers, such as MQTT and AMQP, that aid communication with external devices Connections with 3rd party web services, usually though REST APIs of those services Databases  Either internal to the Yodiwo ecosystem(MongoDB, MySQL, InfluxDB) Or 3rd party ones that Users specify through Cyan and/or Warlock API  Analytics, either 1st or 3rd party, connected either through message brokers, REST, etc. Federation proxies that connect Alcyone to 3rdparty ecosystems, like LoRa, SigFox, Skype, Facebook messenger, etc. This allows not just notification support, but also full control (sense and actuation) of other Things through their respective applications  Nodes A Yodiwo Node is any IP-aware device or software entity that implements the Plegma API and can directly connect to Alcyone,regardless of protocol used\nNodes can simultaneously mix and match several features:\n may or may not present Things of their own can act as IoT Fog server (Wisper), able to under take the execution of IoT App functionality and offload the cloud servers whenever the Alcyone’s engine activates the auto split function. can act as gateway for devices that do not directly use the Plegma API, such as:\n non-IP aware devices (Bluetooth, serial, etc)  not capable of meeting Yodiwo’s security requirements\n devices that are as lightweight as possible (down to 4k of code) and that expect a gateway anyway (e.g. A2MCU nano agents)\n other Yodiwo Nodes that want to take advantage of the Fog server\n software proxies to Yodiwo-unaware devices, 3rdparty cloud platforms or services, etc\n home ecosystem proxies (OpenHAB, Apple Homekit, GoogleNest, Samsung SmartThings, etc)\n  Pairing A Node must be assigned to a known Yodiwo user and given a globally unique Node Key and Secret Key via a process known as Pairing.\nAPI messages may only be exchanged with paired Nodes.\nAfter pairing the Yodiwo cloud service accepts, saves,maintains and presents (through Cyan) a list of Things from each Node. User state and context are retained across user sessions and can be used in Stories where they are interconnected with Services via Logic that the User defines and fine-tunes.\nTypes of nodes A Yodiwo Node can be a monolithic entity created from scratch to provide specific features, or it can use a Plugin architecture to support live, on-the-fly, additions and removals of functionality bundles.\nYodiwo makes extensive use of the cross-platform .Net framework to provide SDKs for both of the above scenarios.\nYodiwo also provides many Node examples in various other languages and platforms:\n C for Linux and various embedded platforms (from NXP, Freescale, Atmel, Marvel, etc) Javascript with REST or WebSockets Java on Android Objective C and Swift on iOS  Execution environment Nodes can run on:\n any hardware, however lightweight (e.g. CortexM0, ESP8266, Arduino, wearables, etc) any Operating System (iOS, Android, Android Wear, Windows families (Win32, Win10 IoT, Win10 Universal, Windows Phone), Linux, minimal RTOS, etc)  Obviously not all of the features mentioned in the previous paragraphs are available on all HW/SW combinations.\nThings A Yodiwo Thing is a model of a physical device or virtual service that virtualizes specific functionality.\nIn practical terms, Yodiwo Things encapsulate and represent “bundles” of related functionality, e.g. a Thing may be a thermostat which has an output (its temperature readout) and one or more inputs (for controlling and configuring it).\nIn general any Thing:\n must belong to a Node can have persistent, user or code editable, configuration can present read-only information may contain zero or more Ports:  a Port holds the minimum amount of information that can be exchanged between Yodiwo and a device can be Input / Output / or bidirectional is the minimum individually addressable entity in Yodiwo topologies can hold and exchange:  Basic types (integer, floating point, boolean values), or encapsulate more complex values (e.g. vectors, or complex classes via JSON encoding)    Other Entities Sub-nodes Sub-nodes are groups of Things that belong to a Node but are in separate subcategory of it\nFor example, they can be used:\n on nano agents which implement a minimal, easily portable API (called “Spike”) that provides non-IP communication with a Yodiwo Node to group Things inside a wearable that belong to a Node running on a Smartphone into a different category  Endpoints Endpoints are identical but “physically” different Nodes. They share the same code, UUID and keys.\nSensor-type events one of them sends are broadcast to all other Endpoints of the same Node. Actuation events are sent to all registered Endpoints.\nKeys and Addressing Every single entity in the Yodiwo topology (Nodes,Endpoints, sub-Nodes, Things, Ports, etc) is uniquely and individually addressable via the Plegma API.\nThere is clear and strictly defined hierarchy between them:\n a Port belongs to a Thing a Thing belongs to a sub-Node or directly to a Node sub-Nodes belong to Nodes a Node belongs to a User  Each of them has a unique Key that is derived from the previous one in its hierarchy, i.e. a Node Key is used to create a Thing Key and this in turn is used to create a Port Key.\nThus, receiving a message about a single Port (channel) indicates:\n the Thing it refers to the node (i.e. API connection) it should have come from the user it belongs to  Any operation can be cross-checked and validated:\n does it come from the proper Node? does it try to access / alter resources that don’t belong to it? does it try to perform operations that it doesn’t have permissions to?  “Broadcast” keys are also supported:\n special Port Key indicates all ports of Thing it belongs to special Thing Key indicates all things of Node it belongs to  Thing Grouping \u0026amp; Thing Sharing Thing Grouping A Yodiwo Thing may have a Type and belong in one or more Hierachies.\nA Type:\n defines semantics, min, max values of each Port, etc can have one or more models, which specify sets of Port semantics, so that the same type(e.g. a Lamp) can have multiple variants naming follows reverse domain name notation  A multitude of basic types (button, location, NFC, BLE beacon, actuator, etc) are defined by Yodiwo. However, Types may also be defined by a 3rd party Node Publisher and provided to Yodiwo at Node connection (via the Plegma API).\nUsers may also assign one or more Tags to Things via Cyan or the Warlock API.\nThings may be grouped per Type, Tag, Hierarchy or manually by the User, again either via Cyan or the Warlock client API.\nEach Group has a unique Group Key according to the rules defined in the previous section. Groups appear as a single entity in Cyan and can be used in “Stories” to apply the same logic to a bundle of Things.\nEvents from any Thing in a Sensor-type Group (Input to Cloud) will trigger all stories the Group has been used in, while still retaining the Thing Key of the triggering device or service. This Thing Key may then be used as the key to database accesses, etc.\nAn actuator-type group may also be placed into stories (Graphs) and the user may choose if the event should be propagated to all Things of the Group or a single one.\nGroups may also be used to perform large scale device management. A user may mass-apply configurations or set the state for a specific Port in all Things of a Group.\nThing Sharing Users may share any Thing they own to other Users.\nShared Things then appear on Cyan in a separate, per-sharer category, and can be used in Stories.\nSensor-type Events from Shared Things trigger:\n Stories of ‘owner’ users, and of Users they have been shared to (sharees)  Actuator-type shared Things may be triggered by:\n events generated in Stories by ‘owners’, and in Stories created and operated by sharees  Sharing preferences may be defined by users via a UI client. Users (the “Sharees”) receiving the shared Things may have chosen to:\n automatically accept all such actions from anyone automatically accept only from known Users always be asked for confirmation, regardless of sender automatically deny every such request, regardless of sender  Re-sharing a shared Thing is never allowed.\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/platform/apis/",
	"title": "APIs",
	"tags": [],
	"description": "",
	"content": " Plegma The Plegma API, from the greek “πλέγμα” meaning grid, mesh or lattice, is the main inter connection API between Alcyone and Nodes of all types.\nIt provides the usual functions one would expect from such an API such as:\n bidirectional declaration and configuration of Things and Nodes bidirectional event passing and triggering  In addition, it includes extensions that allow:\n media(audio and video) streaming IoT processor virtualization (where device high-level drivers run on the cloud) automatic partitioning of Execution Rules between Cloud and Fog servers uploading of binary files  A high level walkthrough of the API can be found at https://www.yodiwo.com/developers. The documentation itself is open-source and suggestions as well as improvements can be directed at github (https://github.com/yodiwo/doc/).\nAutomatically generated formal API reference is also provided at:\n https://yodiwo.github.io/plegma/Plegma/Doxygen/index (Doxygen format) https://yodiwo.github.io/plegma/msdn/ (MSDN format)  The API is of course transport and language agnostic and the following connection methods are currently supported for Plegma Nodes:\nThe block diagram of the API frontend stack is shown below:\nThis is the message flow between Nodes and Alcyone, but it’s not necessary to only carry Plegma messages. Other Yodiwo APIs may be encapsulated within the Plegma link, and if the communicating Node is validated to have the appropriate permissions, the messages will be demultiplexed and sent to the proper handler.\nWarlock Apart from the Plegma API which allows communication for within-the-Node related tasks, the Warlock API is available to Yodiwo users and apps.\nWarlock allows internal control of the User’s context and operations that transcend specific Nodes or Things. It can be used to inquire about relationships with other users, create and deploy new applications, share Things with other users, etc.\nThere is a permission system that specifies which aspects of the system each warlock client is allowed to control.\nNodes can use their Plegma connection to carry Warlock API traffic if they declare the “IsWarlock” capability and have been given the proper permissions.\nFog Apis These APIs specify the communication:\n between user-level software and the Node SDK between Fog gateway plugins and the gateway core between Fog gateway plugins themselves and allows installed plugin discovery, message exchange, RPC and versioning  They are presented in more detail in the separate Fog SW section.\nPlatform Extensibility APIs Under current development are new APIs that allow extensibility of the internal platform.\nAlcyone already allows extensibility via the following methods\n External web services integration via REST  users can create API keys and can use them to create incoming web hooks towards the integrated YPC web server from within a Cyan story they can trigger specific HTTP routes and receive responses that further influence story progression with the use of a wizard they can specify full-fledged external REST APIs that will generate a new custom block that will include all possible (declared) routes and configurations  Integration with generic external entities via MQTT (custom user-specified MQTT broker) Custom code blocks within Cyan  These APIs will formalize the modeling of internal “Logic” blocks and allow external stakeholders to create and upload their own into an app-store like frontend.\nThese blocks will be:\n private to the publisher shared within a publisher’s approved circle public and usable by anyone  Custom user blocks:\n may just be “macro-blocks”, i.e. blocks that include a number of basic blocks or other macro-blocks may provide interfaces to full-fledged external server hosted applications may specify code that is to be executed locally with Alcyone in the user’s context  "
},
{
	"uri": "https://docs.yodiwo.com/doc/wisper/wisper-families/wisper-pro/",
	"title": "Wisper Pro",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/messages/api-overview/",
	"title": "API Overview",
	"tags": [],
	"description": "",
	"content": " Our Cloud Services support a plethora of protocols to carry Plegma API messages, which aids communication between yodiwo-aware nodes and our servers.\nThe Plegma API is publicly accessible and freely available (formal reference found here). Example implementations of the API are freely provided here for popular languages such as C, C#, Java, Javascript and others.\nCurrently available industry-standard protocols:\n HTTP/REST MQTT Web Sockets  Plus:\n YPC (Yodiwo Protocol Channel), a custom, flexible, layered, protocol designed and implemented by Yodiwo that supports:  multiple payload serialization (currently MSGPACK or JSON) multiple transports (currently pure TCP Sockets or AMQP/RabbitMQ) asynchronous or synchronous (blocking RPC) message passing between nodes automatic packing/unpacking both of pre-agreed message types and of unknown members (C# / Java only) throttling, flow control extensible via IEs   In the future we plan to support more methods for developers to reach the Yodiwo Cloud, such as RabbitMQ (a powerful AMQP based protocol) and Google Cloud Messaging.\nMessage Categories The messages in Plegma roughly fall into the following categories (further analyzed in the following pages):\n Message \u0026amp; event passing which carry event triggers from points (Ports of Things in Nodes) to the Yodiwo servers and vice-versa, or between points themselves Things management \u0026amp; control via which Nodes present and manage the Things they encapsulate Node info \u0026amp; discovery where Nodes present themselves and their capabilites and learn about other Yodiwo-aware Nodes Messages that relate to the automatic graph splitting and inter-node synchronization and discovery (currently out of scope for these pages) Messages that aid the Application Agnostic Smart End Devices (currently out of scope for these pages)  All messages in the Plegma API inherit from the same base class, offering uniformity and ease in message entry and parsing.\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Welcome to the Yodiwo Platform! We are an IoT Platform-as-a-Service (PaaS) provider with a unique connectivity framework, based on the first IoT Editor that uses graphs to codelessly interconnect models of Devices and existing Apps with each other.\nour Cyan environment\nNodes and Things The Yodiwo Cloud Platform interacts with Edge devices by sending messages to and receiving messages from them, via a multitude of supported protocols. These messages follow the Plegma framework and API which is described in these pages.\n\u0026ensp;API Reference The complete up-to-date API reference in doxygen format can be found here  The main entity in the Yodiwo Plegma framework is called a Node, which is the implementer of the Plegma API and connects directly to Yodiwo\u0026rsquo;s Cloud. These entities are usually called \u0026ldquo;Edge Nodes\u0026rdquo; in IoT nomenclature, however a Yodiwo Node can also act as a Gateway to other, edgier, Nodes that may for various reasons not directly connect to Yodiwo\u0026rsquo; Cloud. Among the reasons for an end device to require a gateway:\n Legacy or IP-incompatible connectivity protocol Inability to support cost of TCP/IP Inablity to support Plegma\u0026rsquo;s security model  The purpose of this API guide is to help you make your node show up and present itself and its Things here:\nAfter that Users will be able to place said Things from this Node into their graphical stories and have the Yodiwo Cloud exchange messages between them\nA Node is assigned to a known Yodiwo user and given a globally unique Node Key and a Secret Key via a process known as Pairing. The Node and Secret keys are used to authenticate the Node to connection-based protocols and are included in all REST messages.\nAfter pairing is successfully completed, the Node is free to start exchanging Plegma API messages with the Cloud. A Node may use the Plegma API to:\n present itself, its configuration and capabilities to the Yodiwo Cloud service encapsulate and present one or more Things to the Yodiwo Cloud, and allows the Cloud to access those Things send and receive events, from and toward its encapsulated Things. These events are fed into Logic Graphs created by the Cyan Story Creator and can generate new events, either towards the same or other Yodiwo Nodes, or towards 3rd party services start, control and stop video streams from any video-capable (and not Yodiwo-aware) devices perform Node Discovery, through which it can learn about other Nodes that belong to a user (provided that the user has allowed such access)  As mentioned Nodes present one or more Things to the Cloud Service. Things encapsulate and represent “bundles” of related functionality, e.g. a Thing may be a thermostat which has an output (its temperature reading) and one or more inputs (for controlling and configuring it).\nA Thing may have any number of these inputs and outputs, which are called Ports. A Port holds and is used to exchange the minimum unit of information between a Node and the Cloud server:\n Things react to environment conditions generating events related to individual ports. The connection (transient as in REST or persistent) of their parent Node to the Yodiwo Cloud triggers the latter with those events The Yodiwo Cloud triggers events towards the Node, causing it to act on these events  In the following pages we\u0026rsquo;ll present how to create Nodes, Things and Ports, that will then automatically show up in Users\u0026rsquo; Cyan environments to be used in countless stories.\n\u0026ensp;We come bearing gifts Look for our Github page to download fully functional code examples of Node implementations in various popular languages!  "
},
{
	"uri": "https://docs.yodiwo.com/doc/wisper/yodiwo-wisper/",
	"title": "Yodiwo Wisper",
	"tags": [],
	"description": "",
	"content": " Overview This code is split into 2 main sections:\n mNodeCore: main code that generates the mNode base package Plugins: contains Plugin sample code which showcases the Plugin API  Both open under a single Visual Studio (2015) solution.\nmNodeCore It includes all necessary dependencies to build a complete mNode package that:\n is identical to the mNode package downloaded as a package from Yodiwo can autonomously connect to the Yodiwo cloud can be detected by the Yodiwo Wisper Remote Control Android app can present, manage and install Plugins which are published at the Yodiwo Package Manager  Through use of Plugins, mNode can:\n aggregate and terminate different connectivity protocols (such as Bluetooth, Z-Wave, Zigbee, LoRa, etc) expose IP-unaware protocols to the Cloud bridge full-scale 3rd party ecosystems such as OpenHab  The built Node is also configurable to act as a local Fog Gateway providing automatic and manual local analytics, inter-mNode discovery and remote management.\nBuild Just run build from Visual Studio. The Yodiwo.mNode project will create a ready-to-execute build for Windows or Linux under Mono (version 4.2+ is suggested)\nPlugins The included sample Plugins code is meant to showcase writing and embedding a Plugin for mNode. Currently the included plugins are:\n PInvoke: allows using C code via a simple C# to C message exchange mechanism with message queues Serial Port: exposes a serial port as input and output Things on Cyan Flic.io: integrates with Flic bluetooth buttons and exposes each paired button as a separate Thing. Verified on Raspberry Pi 2\u0026frasl;3 with Flic.io\u0026rsquo;s hci library ZWave: integrates with Razberry Z-Wave bridge for Raspberry Pi 2\u0026frasl;3 CPP: allows native C++11/C development without needing any custom C# glue code  After the Plugin is built, it must be placed in a new folder under /mNodeCore/mNode/bin/Release/Plugins/\nThis folder must have the same name as the Plugin\u0026rsquo;s UID in its manifest.json file:\n[..] \u0026quot;PUID\u0026quot;: \u0026quot;Yodiwo.mNode.Plugins.TestPlugin\u0026quot;, [..]  It is advised that Release mode is used, since the referenced DLLs include in the solution have also been built this way.\nWhen running mNode, the new Plugin will be identified and initialized; its registered Things will be sent to the cloud to be used in Apps in the Cyan Workflow Editor.\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/",
	"title": "Plegma",
	"tags": [],
	"description": "Quick overview and guides to get you started with our Plegma API and framework and help you create Things that can access the Yodiwo IoT Cloud Services. Hopefully you&#39;ll be up and running soon!.",
	"content": "Quick overview and guides to get you started with our Plegma API and framework and help you create Things that can access the Yodiwo IoT Cloud Services. Hopefully you\u0026rsquo;ll be up and running soon!.\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/integrators/direct-connection/",
	"title": "Direct Connection to Alcyone",
	"tags": [],
	"description": "",
	"content": " Using RESTful HTTP requests Any entity can send HTTPS requests towards cyan and if a proper graph exists, the requests will trigger it and have it executed.\nUsing 3rd party MQTT brokers If, instead of HTTP, the MQTT protocol is more suitable for the project, then the MQTT block scan be used instead.\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/rest/rest-api/",
	"title": "Get available routes",
	"tags": [],
	"description": "",
	"content": " Definition https://api.yodiwo.com/api/1.0/NODEKEY/SECRETKEY/\nResult Format  200 OK.   {\u0026lt;list of available REST API routes\u0026gt;}   Documentation Returns a simple JSON array of all available API routes\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/mqtt/mqtt-overview/",
	"title": "MQTT support",
	"tags": [],
	"description": "",
	"content": " Overview MQTT doesn\u0026rsquo;t really need an introduction, as it\u0026rsquo;s a well-known, low-latency, simple and lightweight publish-subscribe protocol with implementations for most platforms, including Android, iOS, Linux, minimal embedded systems\nYodiwo’s custom MQTT broker accepts connections from Nodes at api.yodiwo.com (port 8883 for SSL/TLS encrypted connections).\nNodes are expected to have completed Pairing when attempting a connection to the Yodiwo MQTT broker since the assigned Node and Secret Keys will be used for the connection to the broker.\nSpecifically:\n the MQTT Client ID is mandated to be equal to the MQTT username the MQTT username must be set to the Node’s assigned NodeKey string the MQTT password must be set to the Node’s Secret key  Message types and subtopics Payload of the published messages as well as of the messages received via subscriptions is exactly the same as previously described in REST.\nHowever messages are encapsulated in a wrapper that aims to provide support for synchronous operations. For more information see the next section\nMessage encoding is in JSON although binary encoding may be supported at a later time.\nThe supported subtopics are:\n nodeinforeq nodeinforsp thingsreq thingsrsp porteventmsg portstatereq portstatersp  Subscribing to messages After a successful connection the Node need only subscribe to one topic family which encompasses Yodiwo’s API messages as previously outlined and presented in detail in the API reference. The node must subscribe to topics of the following format:\n/api/out/{version}/{NodeKey}/#\nwhere:\n {version} is an integer signifying the API\u0026rsquo;s targeted version number {NodeKey} is the string of the Node’s actual NodeKey Any attempt to subscribe to a topic of a different format, or with an invalid NodeKey that does not match the connection’s Username and Client ID will be rejected.  A Node is allowed to individually subscribe to each message it is interested in, as long as it follows the topic’s prefix format.\nPublishing messages The node may publish data using the following topics:\n/api/in/{version}/{UserKey}/{NodeKey}/\u0026lt;apimsgname\u0026gt;\nwhere\n {version} is an integer signifying the API\u0026rsquo;s targeted version number {UserKey} is the string of the owner of the Node’s UserKey {NodeKey} is the string of the Node’s actual NodeKey \u0026lt;apimsgname\u0026gt; refers to the same message names as previously shown  Outro Summarizing for both publishing and subscribing directions:\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/integrators/connection-via-plegma-api/plegma-nodes-credentials/",
	"title": "Plegma Nodes Credentials",
	"tags": [],
	"description": "",
	"content": "Plegma Nodes must be assigned a Node Key and a Secret Key, using either of the following:\n a pairing process\n a platform-aided provisioning process\n direct key generation from Cyan’s UI\n custom use of the Warlock API\n  This should be the integrator’s choice that is dependent on the intended final application:\n Pairing implies that each end-user is a separate Yodiwo account holder, i.e. the end device (node) is the same for multiple end-users, each of which must pair it to their own Yodiwo account.\n The rest of the provisioning methods imply that the end user is not and need not be aware of this process. Use of the platform happens under-the-hood and serves the application’s, service’s or OEM’s connectivity needs.\n  Yodiwo provides tools for both options:\n Pairing agents are provided for all major platforms where Node Plegma API agents are provided. Pairing can:\n be either completely stand-alone for platforms that can offer a user-login GUI\n or, for GUI-less devices, be remotely assisted by a GUI-capable device where the end-user can complete a login procedure.\n   Security is maintained on both cases; more information about the pairing process can be found in [TODO: Dlt or Link]\n Nodes and node credentials (node and secret keys) can:\n be created directly in the Things Manager section:   be created in bulk through a Warlock API client\n be created via a graph in Cyan itself, using the Create Node and Create API Key blocks found in the Cyan Designer Toolbox “Platform” section:\n      Similar to how API keys can be created to enable REST services (discussed later in this document), API keys can also be linked to Nodes and be used for allowing edge devices to connect to the Cloud Backend through the Plegma API. In this case the Node does not need to know / keep the Master Key generated through the pairing process, and can instead just use the linked API Key.\nThis also allows the integrator to better control node access, since API keys can be individually enabled/disabled (without being removed) and can have their Quota tracked.\nLinked API keys can be generated:\n through use of the Warlock API  automatically through the graph, using the previously mentioned blocks    or manually through Cyan\u0026rsquo;s UI:  ​ ​ Generate API keys Manually\n​\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/integrators/direct-connection/using-3rd-party-mqtt-brokers/",
	"title": "Using 3rd party MQTT brokers",
	"tags": [],
	"description": "",
	"content": "Yodiwo already provides its 1st party MQTT broker (at api.yodiwo.com:8883) for Plegma API connections, but any existing 3rd party broker can be used instead.\nSo to publish any message, the MQTT out block can be configured and used:\nConversely, to subscribe to topics, listen to messages and have them trigger graphs, insert and configure use the MQTT input block:\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/integrators/connection-via-plegma-api/",
	"title": "Via the Plegma API",
	"tags": [],
	"description": "",
	"content": "As discussed a device that implements Yodiwo’s Plegma is called a Yodiwo Node. The Plegma API offers significantly powerful ways to:\n Modelling Things and automatically presenting them to the Cyan Workflow Editor or any other Warlock API Client Bidirectional event passing State syncing Persistent and retrievable configuration for Things On-the-fly Thing generation, removal or updates from either side (cloud or nodes) Sharing of Things between accounts Grouping of Things; multiple Things easily deployed in IoT scenarios and configured in bulk Simultaneous connections from multiple endpoints  "
},
{
	"uri": "https://docs.yodiwo.com/doc/integrators/connection-via-plegma-api/plegma-things-creation-and-handling/",
	"title": "Plegma Things Creation and Handling",
	"tags": [],
	"description": "",
	"content": "A node’s main purpose is to maintain and present a list of Things, each of which models and virtualizes a real digital function, either physical or logical.\nUpon a successful connection the Node sends their list of Things (each with a globally unique Thing Key) to the cloud, while it can also retrieve the Cloud’s previously synced Thing lists along with their configurations. As a result of this process, Cyan’s Designer Toolbox automatically presents the Node in its green section, populated with the latest version of the Node’s virtualized Things:\nThings consist of one or more Ports, each of which sends or receives the minimum amount of data that can be exchanged and perform an operation related to the Thing.\nZero-port Things are allowed. They are useful in that they offer configuration options. Changing their configuration from Cyan will trigger events on the Node they belong to. Configuration can be changed either from the Designer section (once dropped into the canvas) or from the Things Manager tables’ Action column\nMultiple-port Things can trigger or be triggered on each Port individually or in multiples.\nIn the latter case Plegma and Alcyone guarantee concurrent handling of all triggered Ports, i.e. there is no timing, delays or races between handling of each Port, and the Nodes/Cloud will operate on the updated Thing as whole\nNodes can present their Things at connection time, or update, create or delete them at any later time. Plegma provides a mechanism to sync Thing revision numbers between the Cloud and Nodes, so that Things are not exchanged while both sides are in sync.\nSensor-type Things will appear as blocks that provide input to graphs. I.e. a device that virtualizes and presents beacon functionality will appear as:\nWhen the Node sends an actual beacon to Alcyone, it will trigger its next connected block(s) as designed in graphs by the Developer of the IoT scenario.\nThe same Thing block may appear in many different graphs and be connected to many different devices. They all represent the same Thing. Alcyone will trigger all blocks with the same event. By definition and by design there are no race sand there is no timing between blocks.\nOne may need to synchronize handling between events that come from independent asynchronous sources. In this case a special sync block may be used:\nActuator-type Things will appear as blocks that receive input from graphs. I.e. a device that virtualizes and presents a torch functionality (e.g. a smartphone’s LED) will appear as:\nThis block receives Boolean events (or any other type that can automatically be converted to Boolean). Upon reception of the event, all Node endpoints that are currently active and connected to Alcyone will receive the event and be expected to immediately act on it.\n If nodes are offline at that time, the value is cached and Plegma offers a mechanism (Port State Get/Set) for it to be synced upon connection. Multiple lost events overwrite their previous one If an actuator is placed on different graphs, driven by different asynchronous inputs, and multiple points write to it “at the same time”, then its actuations do not have a guaranteed order. They will all be served, in random order, resulting in toggles, overwrites or similar outcomes.  Things that simultaneously offer Sensor and Actuator Ports functionality will still be automatically represented as two unique blocks. Same goes for Things with a single Input-Output Port such as a light switch that can be driven but whose output can also be used as an input to the graph:This is intentional and by design. Even if a Thing X sensor value is directly triggered by a Thing X’s actuator (as in a polling fashion), it needs to be shown clearly that:\n the target Node endpoint(s) shall be found, and if currently online…\n the trigger / actuation event will leave the platform\n traverse through the Plegma Link towards the Node\n the node must act on it and generate an event(Port Event Msg)\n send it back to Alcyone for it to trigger the relevant graph(s) where this Thing’s Block representation is placed\n  Code on the Node side controls all of these aspects of Things and much more:\n Type of each Port’s messages (boolean, strings, decimals, integers, etc)\n Icon of Thing\n Description (per-Port and of Thing in general) that will appear when Cyan user hovers over the Thing\n Changeable configuration entries of Thing.\nNOTE: changing configuration via the “Edit” field of the Thing dropped on canvas will update the Thing “everywhere”. In reality there is no “everywhere”, each Thing is unique and belongs to its node, all its Cyan representations (e.g. on different graphs) refer to the same single Thing.\n Read-only information of Thing\n  "
},
{
	"uri": "https://docs.yodiwo.com/doc/platform/yodiwo-fog-gateway/",
	"title": "Yodiwo Fog Gateway",
	"tags": [],
	"description": "",
	"content": " Description The Fog gateway is a Yodiwo Node, as previously defined, with special features and capabilities.\nIt is cross platform software based on the Microsoft .Net frame work and can run on any Windows PC, Linux, Android, iOS, or embedded ARM-based devices such as the Raspberry Pi running Linux or Windows IOT. It can also be provided as final hardware, either branded as Yodiwo or with the customer’s brand.\nArchitecture A Yodiwo Node can be a monolithic entity created from scratch to provide specific features, or it can use a Plugin architecture to support live, on-the-fly, additions and removals of functionality bundles.\nBoth cases are based on the Yodiwo Node SDK, which in turn is based on Microsoft’s .Net software platform.\nThe Yodiwo Fog gateway ( Wisper ) uses many of the mentioned Node capabilities:\n acts as an IoT Fog server, automatically splitting functionality between Alcyone and Nodes identifies other Yodiwo nodes currently within its vicinity (for now this means with the same LAN) and link with them to directly exchange messages and if applicable bypass Yodiwo’s cloud, severely reducing latency acts as a gateway for devices that do not directly use the Plegma API acts as a proxy to Yodiwo’s cloud devices for Yodiwo-agnostic 3rd party cloud platforms or services (like OpenHAB, Apple Homekit, Google Nest, Samsung SmartThings, etc)  The basic architecture of Wisper based on the Node SDK is as follows:\nMonolithic nodes Developers (and Yodiwo) can choose to code directly against the Node SDK, resulting in monolithic, single-purpose applications, that may still use all of Yodiwo’s advanced features such as Graph Splitting, Cross-Node discovery, dynamic rerouting, etc.\nExamples of current applications which make direct use of this SDK are:\n ModBus slave \u0026amp; master Z-Wave proxy BACnet proxy LoRa gateway 3rd party ecosystem proxy (GoogleNest, Samsung SmartThings) 3rd party IoT platform integrator(for IBM Bluemix, Amazon AWS, MS Azure) OpenHAB proxy Camera proxy Yodiwo integration with Dexter Industries’GrovePi kit etc  Any of the above, and any Node SDK client in general, can be built with the “local Fog execution” option enabled, meaning that they can benefit from automatic scenario splitting and dynamic event rerouting.\nThrough Microsoft Xamarin all of above can also run on Android and iOS, retaining all thus far mentioned benefits.\nExtensible nodes Yodiwo has also developed an open plugin framework and API on top of the Node SDK.\nDevelopers (and Yodiwo itself) can create new plugins against this framework, and users can download and on-the-fly install them on their gateway.\nThese nodes, and all their plugins, retain all advanced features offered by Yodiwo, including splitting and dynamic rerouting.\nIn addition, plugins can directly address each other, interoperate and execute RPC (Remote Procedure Calls), either synchronously (blocking until an answer is returned) or asynchronously.\nThe framework automatically and without developer effort provides for versioning, compatibility checking for inter-plugin IPC, and automatic updating of plugins, as well as the core Gateway code.\nExisting plugins include:\n OpenHAB support (OpenHAB is provided as both a plugin and a monolithic Node) Audio and Video streaming support Camera discovery via the OnVIF protocol Google Nest Plugin to integrate with closed-source libraries provided as Windows .dll or Linux .so objects  Installation \u0026amp; Packaging Fog SW and selected plugins can come preinstalled and preconfigured on Gateway hardware (such as the Raspberry Pi 1/2/3). From there users can administer and configure them either through a Web based GUI, a Windows WPF app, or mobile apps (Android, iOS, Xamarin Forms). They can also install new plugins through the same means.\nAdditionally, for Linux-based gateways all Nodes and plugins are packaged, installable and upgradeable through the Debian’s Apt framework (# apt-get install), while a Windows msi installer is also provided for Windows systems.\nCore and plugins software can be updated automatically and without user intervention, if required.\nIn the future, the up-and-coming cross-distribution Snap framework will also be used for packaging and installation.\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/wisper/wisper-families/",
	"title": "Wisper Families",
	"tags": [],
	"description": "",
	"content": "Put wisper overview here\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/messages/base-api-message-class/",
	"title": "Base API message class",
	"tags": [],
	"description": "",
	"content": " ApiMsg Virtually all Plegma API messages inherit from this ApiMsg abstract class:\n C#   .   Java   .   C  ·   Objective-C      namespace Yodiwo.API.Plegma { public abstract class ApiMsg { public int SeqNo; } }    package com.yodiwo.PlegmaApi; public abstract class ApiMsg { public int SeqNo; }    typedef struct Yodiwo_API_Plegma_ApiMsg { int32_t SeqNo; } Yodiwo_API_Plegma_ApiMsg_t;    @interface APIMsg : JSONModel @property (nonatomic) NSInteger SeqNo; @end     This base class contains just the sequence number of the message:\n SeqNo: the unique Id of this particular message.  it is mandatory for the Cloud to set this to a unique, monotonically increasing number in every message towards Nodes, so that you can identify lost messages (after all, embedded Nodes are allowed to have their own sleep schedules) While it is not mandatory for Nodes to set this field in the messages they send to the Cloud, it is advised, so that cloud code can perform rejection of duplicate messages. However, even if you implement sequence numbering for messages, you can bypass it for individual messages by setting SeqNo to 0 for these messages. Those messages will always be handled by the cloud, without checking sequence numbers.   Suffixes in all Plegma API messages provide information about the kind of message. In message and with a singular exception, all messages are blocking ones and expect a response, even if the latter is a generic \u0026ldquo;ack\u0026rdquo;-type one.\n Req means that the sender (either the node or the cloud server) sends actionable data and expects an answer in the form of an Rsp message. Rsp means that the message is a response to a preceding message, either containing actual data or acting as an Acknowledge message. Get is a call to action. It contains no actionable information itself but contains a request for the receiver to send something back. The sender blocks until the reply is received. Set is either the reply to a previous Get-type message, or a new message that directly sends new information. The latter case still expects an ACK which is usually a GenericRsp message. Msg is an asynchronous message originating at any time from the Node or from the Cloud that does not expect an answer. There are precious few of those, currently limited to status-updated events  \u0026ensp;Node-to-Cloud RPC You can also use RPC mechanisms towards our Cloud servers. Take a look at the reference RPC-over-MQTT example source code that you\u0026rsquo;ll find in our github page  \u0026ensp;Synchronous requests For protocols that do not inherently support synchronous, blocking calls (like MQTT) or , implementation of a synchronous Req/Rsp mechanism is left to a protocol wrapper instead. For more information have a look at the respective protocol help sections  GenericRsp As mentioned, synchronous request-type messages require responses, and sometimes those are generic ACK-type response that offer little more than confirmation of whether a message was successfully parsed. For those there is the GenericRsp message:\n C#   .   Java      package com.yodiwo.PlegmaApi; public abstract class ApiMsg { public int SeqNo; }    public class GenericRsp extends ApiMsg { { public Boolean IsSuccess; public int StatusCode; public String Message; public GenericRsp() { } }       IsSuccess: basic boolean (ok or not) feedbck on received message StatusCode: generic integer, the meaning of which, if any, depends on actual message exchange Message: human readable text containing status for received message  "
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/rest/rest-api-things-get/",
	"title": "Get Things",
	"tags": [],
	"description": "",
	"content": " Definition https://api.yodiwo.com/api/1.0/NODEKEY/SECRETKEY/thingsget\nParameters    Name Type     nodekey  required string n/a  NodeKey (received during Node pairing)   secretkey  required string n/a  SecretKey (received during Node pairing)    Documentation Sends a Things Get request to the cloud server. Route parameters include the Node and Secret keys received during the Node\u0026rsquo;s pairing. The body of the message is expected to be a JSON-serialized message of the ThingsGet class.\nThe server will reply with a Things Set response.\nFor more information check out Things management \u0026amp; control\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/mqtt/message-format/",
	"title": "Message format",
	"tags": [],
	"description": "",
	"content": "In order to support synchronous (blocking) messages with MQTT -which doesn\u0026rsquo;t inherently provide this capability- there needs to be a way to match new messages (Responses) to previous ones (Requests). To that end a very simple message wrapper is introduced:\n[any language].   public class MqttMsg { public eMsgFlags Flags; public int SyncId; public string Payload; }    Flags: this field distinguishes between:\n Request-type messages (Get or Req) that mandate a response (Rsp or Set) Response-type messages to previous requests simple asynchronous messages  Specifically Flags is:\npublic enum eMsgFlags { None = 0, //async message Request = 1, //message is request and expects response Response = 2 //message is response to previous request }  SyncId: for a request that expects a response, this must be set to a non-zero, monotonically increasing number for a message that is a response to a previous request (Req or Get), this must be set to the original message\u0026rsquo;s SyncId as previously described. for an async message the field should be ignored\n Payload: the JSON serialized Plegma API message that is being sent\n  For example, the following NodeInfoRsp message:\nText\n{ \u0026quot;Name\u0026quot;:\u0026quot;node\u0026quot;, \u0026quot;Type\u0026quot;:2, \u0026quot;Capabilities\u0026quot;:0, \u0026quot;ThingTypes\u0026quot;:null, \u0026quot;ThingsRevNum\u0026quot;:4, \u0026quot;SupportedApiRev\u0026quot;:1, \u0026quot;BlockLibraries\u0026quot;:null }  that is a response to a NodeInfoReq message with SyncId=34 should be sent as:\nText\n{ \u0026quot;SyncId\u0026quot;: 34, \u0026quot;Flags\u0026quot;:2, \u0026quot;Payload\u0026quot;: \u0026quot;{\\\u0026quot;Name\\\u0026quot;:\\\u0026quot;node\\\u0026quot;,\\\u0026quot;Type\\\u0026quot;:2,\\\u0026quot;Capabilities\\\u0026quot;:0,\\\u0026quot;ThingTypes\\\u0026quot;:null,\\\u0026quot;ThingsRevNum\\\u0026quot;:4,\\\u0026quot;SupportedApiRev\\\u0026quot;:1,\\\u0026quot;BlockLibraries\\\u0026quot;:null}\u0026quot; }  "
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/pairing-overview/",
	"title": "Pairing Overview",
	"tags": [],
	"description": "",
	"content": " All Nodes need to go through a “pairing” process in order for them to be allowed to exchange data with the Yodiwo cloud. This process is also known as Provisioning or Commissioning.\nPairing assigns a Key and a secret token to the node, both of which are used to later establish connections to the Yodiwo Cloud Platform over secure channels.\nThe pairing process is defined for two classes of Node devices, those that do not have a GUI of their own and those that do. The process for both is similar. Complete, verified, reference implementations are provided for both by Yodiwo; check relevant examples for your preferred language on GitHub.\nNodes without a GUI These nodes do not have a screen of their own or other means of projecting to a screen. They are also assumed to be not powerful enough to implement a secure HTTPS web server, but are capable of acting as a client to a secure server, as that is a fundamental requirement for a Node of Yodiwo\u0026rsquo;s Platform.\nHence the method needs the device to:\n become discoverable (via some form of service discovery if Ethernet, SoftAP if WiFi, visible if Bluetooth, etc) implement and start a simple HTTP server (not necessarily secure), or just be able to respond to 2 basic GET requests be able to access a secure HTTPS server as a client  From these basic requirements a pairing process is devised that allows the node to only be paired with the Yodiwo account of its owner, even if the non-secure part of the communication is eavesdropped. In the latter case, if the attacker tries to hijack the node and pair it to their own account, the node is guaranteed to not be paired at all; the rightful owner (i.e. the one who has physical access to the device and its UUID) is informed via their Yodiwo account.\nAt the start of the procedure, the user is instructed to find and connect (if necessary by its physical interface) to the device, then visit its web page at http://\u0026lt;deviceip\u0026gt;/pairing/start where they will be instructed to follow the instructions for pairing, which is a simple 2-step process. The technical details of this process is seen in the following sequence diagram, and as mentioned, code for it in most major languages (C, Java, JS, Objective-C, C#) is provided by Yodiwo at GitHub.\nThe following sequence diagram describes the pairing procedure in detail:\nSequence diagram of secure pairing of a GUIless node\nUpon receiving a pairing request (an HTTP Request for \u0026lt;deviceid\u0026gt;/pairing/start) the Node (without yet sending a Response) securely (over an SSL/TLS channel) sends capabilities, configuration and its UUID to the Cloud Server. The cloud server generates two tokens and a secret key and securely sends the 2 tokens (but not the secret key) back to the Node.\nAs a Response to the original pairing request, the node then:\nredirects the User’s browser to the Yodiwo Server so that they securely login and authenticate with Yodiwo, and sends Token2 as a parameter (?token2=\u0026lt;token\u0026gt;) It must be noted that this action happens over a non SSL/TLS secured channel (even a strongly encrypted Wi-Fi link is not considered end-to-end secure) and hence an eavesdropper may have acquired Token2. It is therefore important to make sure that such a case cannot lead to a faux-pairing and the hijacking of a legitimate user’s device. The Node’s response redirects the User’s browser to the Yodiwo cloud service pairing page. If they are not already logged in, they are required to securely log in to their Yodiwo account (via redirection). After successful login they are automatically taken back to the pairing page where they enter the Node’s UUID. This step can also be completed without manual entry, e.g. via NFC or QR code sent from an already paired device such as a smartphone. Afterwards the browser triggers the node to complete the pairing process at which point the node securely sends Token1 to the Cloud Service.\nAt this point the Cloud Server evaluates that:\n securely received Tokens 1 and 2 are the same as the ones it originally generated; an attacker may also know Token 2 but they cannot send it to Yodiwo without being a registered user. UUID received securely by the logged in User is the same as the one originally securely sent by the Node. Even an attacker who is a registered Yodiwo user can only know Token2, not the Node’s UUID since the latter requires physical access to it.  If everything is in order, the Server securely sends the Node Key and Secret API Key to the Node. These must be used for all Node \u0026lt;-\u0026gt; Server communication from now on, which as previously mentioned, is mandated to occur over a secure channel.\n\u0026ensp;Notes  Since all these steps are done with redirects the user never actually has to type any addresses after the initial http://\u0026lt;deviceid\u0026gt;/ one (which also may be avoided via Service Discovery) The user may manually enter their Node’s UUID, although manual entry can be avoided through the use of QR codes (no external applications needed, modern browsers –desktop and mobile- allow this) Recap: even if Token2 is acquired by an attacker, pairing cannot be successfully completed without: A valid login to the Yodiwo ServicePhysical access to the newly acquired Node to read / scan its UUID\nA Node hijacking attempt will fail and the legitimate user will be notified (through their account) ​  ​  ​    Nodes with a GUI The main difference is that GUIful nodes usually shed the limitation of having a 3rd party GUI (e.g. a browser web page) act as mediator and communicate insecurely with the node and securely with the Yodiwo servers. Hence they could in theory POST a start pairing request with configuration, get redirected to log in to the Yodiwo service and then immediately exchange Node and Secret keys. Currently these nodes still exchange tokens and the pairing backend in Yodiwo servers remains the same, resulting in the following sequence diagram:\nSequence diagram of secure pairing for a Node with a GUI\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/messages/",
	"title": "API Messages",
	"tags": [],
	"description": "Quick overview and guides to get you started with our Plegma API and framework and help you create Things that can access the Yodiwo IoT Cloud Services. Hopefully you&#39;ll be up and running soon!.",
	"content": "Quick overview and guides to get you started with our Plegma API and framework and help you create Things that can access the Yodiwo IoT Cloud Services. Hopefully you\u0026rsquo;ll be up and running soon!.\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/rest/rest-api-things-set/",
	"title": "Set Things",
	"tags": [],
	"description": "",
	"content": " Definition https://api.yodiwo.com/api/1.0/NODEKEY/SECRETKEY/thingsset\nParameters    Name Type     nodekey  required string n/a  NodeKey (received during Node pairing)   secretkey  required string n/a  SecretKey (received during Node pairing)    Documentation Sends a Things Set request to the cloud server. Route parameters include the Node and Secret keys received during the Node\u0026rsquo;s pairing. The body of the message is expected to be a JSON-serialized message of the ThingsSet class.\nThe server will reply with the body of a GenericRsp response.\nFor more information check out Things management \u0026amp; control\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/messages/things-ports/",
	"title": "Things &amp; Ports",
	"tags": [],
	"description": "",
	"content": " Nodes implement the Plegma API to allow communication and interaction with our cloud, but their main purpose is to expose and manage Things, the entities that actually do stuff. In this section we describe how to create them and the Ports they enclose, while in the Things management \u0026amp; control section we\u0026rsquo;ll talk about how to sync them with our cloud.\nSo without further delay..\nThings ..a Thing is this:\nC#.  Java.  C·  Objective-C    public class Thing { public string ThingKey; public string Name; public List\u0026lt;ConfigParameter\u0026gt; Config; public List\u0026lt;Port\u0026gt; Ports; public string Type; public string BlockType; public bool Removable; public ThingUIHints UIHints; }    public class Thing { public String ThingKey; public String Name; public ArrayList\u0026lt;ConfigParameter\u0026gt; Config; public ArrayList\u0026lt;Port\u0026gt; Ports; public String Type; public String BlockType; public Boolean Removable; public ThingUIHints UIHints; }    typedef struct Yodiwo_Plegma_Thing { char* ThingKey; char* Name; Array_Yodiwo_Plegma_ConfigParameter_t Config; Array_Yodiwo_Plegma_Port_t Ports; char* Type; char* BlockType; public bool_t Removable; Yodiwo_Plegma_ThingUIHints_t UIHints; } Yodiwo_Plegma_Thing_t;    @interface Thing : JSONModel @property (strong, nonatomic) NSString *thingKey; @property (strong, nonatomic) NSString *name; @property (strong, nonatomic) NSMutableArray\u0026lt;ConfigParameter\u0026gt; *config; // of ConfigParameter @property (strong, nonatomic) NSMutableArray\u0026lt;Port\u0026gt; *ports; // of Port @property (strong, nonatomic) NSString *type; @property (strong, nonatomic) NSString *blockType; @property (strong, nonatomic) BOOL Removable; @property (strong, nonatomic) ThingUIHints *uiHints; @end @interface ThingUIHints : JSONModel @property (strong, nonatomic) NSString *iconUri; @property (strong, nonatomic) NSString *description; @end     It includes:\n the ThingKey: a string that globally and uniquely identifies this particular Thing among all Yodiwo Things in the known universe (because it encloses the also-quite-unique NodeKey). You create this key using a constructor that we provide and your own unique-to-this-node ID.\n Name: a user-friendly name which will be used to present the Thing in the Cyan environment\n Array / List of configuration parameters, which are Name-Value pairs of any configuration that you\u0026rsquo;d like the Thing to expose. Users will be presented with these configuration options in the Cyan environment and will be able to view and/or change them\n Array / List of Ports, discussed at length later in this page\n Type: a string that matches this Thing\u0026rsquo;s type to a ThingType, if any. Although it can be left blank, it may be important to match it to a Type, as this allows users to directly interact with this Thing (group it with other Things of the same Type, alter its configuration, directly send values, etc) through the Cyan\u0026rsquo;s environment Thing Manager. Please refer to ThingType in the api reference for more info on Types or consult the sample code provided within the same resources. If left empty, users can of course still see the Thing in Cyan and use it in graphs.\n BlockType: This can be left blank if this Thing can be adequately represented by Cyan\u0026rsquo;s default model for Things, where each of its Ports sends and receives State strings. If special treatment is required, we\u0026rsquo;ll create a model tailored to your needs and provide you with a new BlockType string that will be inserted here\n Removable: boolean that specifies to the server whether users are allowed (and it makes sense) to remove this Thing or not. If left false, your Node will not receive ThingsSet messages of the Delete operation type for this Thing. If the user tries to delete the Thing, it will be hidden instead and not be available for use in Stories\n UIHints: class that includes information on how to present this Thing in the Cyan environment. Currently the available entries are:\n String UIHints.IconURI: a publicly accessible URI (e.g. a public Dropbox link) of the icon you wish it to have. Most icon formats (.ico, .png, svg, etc) are supported although vector based ones are preferred due to their superior scaling String UIHints.Description: Description of the Thing to be shown at various places within the Cyan environment (e.g. tooltips, Thing tables, documentation, etc)   Each Thing has one or more Ports:\nPorts Each Thing is an island of functionality and Ports are the points it uses to exchange information with\nA simple button Thing may have a single output Port that triggers a message whenever it is pressed or depressed.\nA button has no input Ports because it is completely event based, however a Thing representing a switch may have an output port triggering a message whenever it changes state, while also providing an input port allowing its configuration or sampling of its state at any time.\nMore complex things can have multiple input and output ports, allowing them to be sampled -or triggered- by external entities, while also generating events of their own towards others.\nOur Port representation is:\nC#.  Java.  C·  Objective-C    public class Port { public string PortKey; public string Name; public string Description; public ioPortDirection ioDirection; public ePortType Type; public string State; public int RevNum; public ePortConf ConfFlags; }    public class Port { public String PortKey; public String Name; public String Description; public ioPortDirection ioDirection; public ePortType Type; public String State; public int RevNum; public ePortConf ConfFlags; }    typedef struct Yodiwo_Plegma_Port { char* PortKey; char* Name; char* Description; Yodiwo_Plegma_ioPortDirection ioDirection; Yodiwo_Plegma_ePortType Type; char* State; int32_t RevNum; Yodiwo_Plegma_ePortConf ConfFlags; } Yodiwo_Plegma_Port_t;    @interface Port : JSONModel @property (strong, nonatomic) NSString *portKey; @property (strong, nonatomic) NSString *name; @property (strong, nonatomic) NSString *description; @property (nonatomic) EnumIOPortDirection ioDirection; @property (nonatomic) EnumPortType type; @property (strong, nonatomic) NSString *state; @property (nonatomic) NSInteger revNum; @property (strong, nonatomic) EnumPortConf confFlags; @end     Its members are:\n PortKey: a string that, again, globally and uniquely identifies this Port among all Ports (because it incorporates the also-unique ThingKey). You create this key using a constructor that we provide and your own unique-to-the-thing ID string.\n Name: a user-friendly name which will be used to present the Port in the Cyan environment (the connection dot\u0026rsquo;s name in the block). Although not advised, it is allowed to be left null for absolutely-obvious ports (e.g. the single output of a butto\n Description: a human-targeted description of the Port\u0026rsquo;s functionality and purpose. This will show up as a tooltip when the user hovers over the port in the Cyan environment\n ioDirection: may be set to Input, Output or InputOutput:\nenum ioPortDirection { //both Input and Output, Port will be used in both Graph Input and Output Things InputOutput = 1, //Port will be used only in Graph Input Things (node-\u0026gt;cloud) Output = 2, //Input only; Port will be used only in Graph Output Things (cloud-\u0026gt;node) Input = 3 }   In addition to those values, if using a custom model for the Port\u0026rsquo;s parent Thing, then a Port\u0026rsquo;s state could be a custom JSON-serialized string representing a complex type\n State: this should hold the last saved State of this Port (for Ports that this saving makes sense). It is a string encoding of the previously discussed Type\n RevNum: The Revision number of the last State\u0026rsquo;s update (each State is unique and assigned a monotonically increasing number; this number is maintained by the Cloud server and used in PortEvent messages as discussed here)\n ConfFlags: bitmap of configuration flags per port\nenum ePortConf { //specifies whether port should propagate all events, i.e. even values //that are identical to the port's previous value but were triggered in //a graph. Event will still have an updated RevNum value PropagateAllEvents = 1, //marks port as a trigger (this may have an effect on where it's placed on the //block model and how events from it are propagated) IsTrigger = 2 }   Please see Message \u0026amp; event passing for more information on the whys and hows of this\nExamples here are some real-world examples of Things / Ports definitions:\nC#.  Java.  C·  Objective-C    //Setup a tri-color RGB LED Thing { //setup the LED thing itself var RgbLedThing = new Yodiwo.API.Plegma.Thing() { ThingKey = new ThingKey(NodeKey, _generateThingID()), Name = \"Raspberry tri-color Led\", Config = null, UIHints = new ThingUIHints() { IconURI = \"/Content/RaspberryNode/img/icon-rgb-led.png\" } }; //setup its three boolean input ports (receiving events to //turn the LED on/off), one for each LED color thing.Ports = new List\u0026lt;Yodiwo.API.Plegma.Port\u0026gt;() { new Yodiwo.API.Plegma.Port() { PortKey = new Yodiwo.API.Plegma.PortKey(thing, \"0\"), Name = \"Red\", ioDirection = Yodiwo.API.Plegma.ioPortDirection.Input, Type = Yodiwo.API.Plegma.ePortType.Boolean, State = \"0\" }, new Yodiwo.API.Plegma.Port() { PortKey = new Yodiwo.API.Plegma.PortKey(thing, \"1\"), Name = \"Green\", ioDirection = Yodiwo.API.Plegma.ioPortDirection.Input, Type = Yodiwo.API.Plegma.ePortType.Boolean, State = \"0\" }, new Yodiwo.API.Plegma.Port() { PortKey = new Yodiwo.API.Plegma.PortKey(thing, \"2\"), Name = \"Blue\", ioDirection = Yodiwo.API.Plegma.ioPortDirection.Input, Type = Yodiwo.API.Plegma.ePortType.Boolean, State = \"0\" } }; }    // Things to represent the sensor outputs of Android phones // ---------------------------------------------- // Brightness { ThingKey thingKey = ThingKey.CreateKey(nodeKey, Brightness); thing = new Thing(thingKey, \"BrightnessSensor\", new ArrayList\u0026lt;ConfigParameter\u0026gt;(), new ArrayList\u0026lt;Port\u0026gt;(), \"\", \"\", new ThingUIHints(\"/Content/VirtualGateway/img/brtness.png\") ); thing.Ports.add(new Port(\"BrightnessVal\", ePortType.Decimal, ioPortDirection.Output, PortKey.CreateKey(thingKey, \"0\"), 0, \"0\")); } // ---------------------------------------------- // NFC NfcAdapter mNfcAdapter = NfcAdapter.getDefaultAdapter(context); if (mNfcAdapter != null) { ThingKey thingKey = ThingKey.CreateKey(nodeKey, OutputNFC); thing = new Thing(thingKey, \"OutputNFC\", new ArrayList\u0026lt;ConfigParameter\u0026gt;(), new ArrayList\u0026lt;Port\u0026gt;(), \"\", \"\", new ThingUIHints(\"/Content/VirtualGateway/img/nfc.png\") ); thing.Ports.add(new Port(\"NfcReadout\", ePortType.String, ioPortDirection.Output, PortKey.CreateKey(thingKey, \"0\"), 0, \"0\")); } // ---------------------------------------------- // GPS thingKey = ThingKey.CreateKey(nodeKey, GPS); thing = new Thing(thingKey, GPS, new ArrayList\u0026lt;ConfigParameter\u0026gt;(), new ArrayList\u0026lt;Port\u0026gt;(), \"\", \"\", new ThingUIHints(\"/Content/VirtualGateway/img/gps.png\") ); thing.Ports.add(new Port(\"Position\", ePortType.String, ioPortDirection.Output, PortKey.CreateKey(thingKey, \"0\"), 0, \"\")); NodeService.AddThing(context, thing);    [coming soon..]    // Virtual switch { NSString *thingUID = @\"iOSSwitch\"; ThingKey *thingKey = [[ThingKey alloc] initWithNodeKey:nodeKey andThingUid:thingUID]; Port *port = [[Port alloc] init]; port.name = @\"Switch state\"; port.ioDirection = EnumIOPortDirection_Output; port.type = EnumPortType_Boolean; port.portKey = [[[PortKey alloc] initWithThingKey:thingKey andPortUid:@\"0\"] toString]; NSMutableArray *ports = (id)[NSMutableArray new]; [ports addObject:port]; ThingUIHints *uiHints = [[ThingUIHints alloc] init]; uiHints.iconUri = @\"/Content/VirtualGateway/img/switch.png\"; [[NodeController sharedNodeController] addThing:[[Thing alloc] initWithThingKey:[thingKey toString] name:[deviceName stringByAppendingString:thingUID] config:nil ports:ports type:@\"iOSVirtual\" blockType:@\"\" uiHints:uiHints]]; } // Virtual slider { NSString *thingUID = @\"iOSSlider\"; ThingKey *thingKey = [[ThingKey alloc] initWithNodeKey:nodeKey andThingUid:thingUID]; Port *port = [[Port alloc] init]; port.name = @\"Slider value\"; port.ioDirection = EnumIOPortDirection_Output; port.type = EnumPortType_Decimal; port.portKey = [[[PortKey alloc] initWithThingKey:thingKey andPortUid:@\"0\"] toString]; NSMutableArray *ports = (id)[NSMutableArray new]; [ports addObject:port]; ThingUIHints *uiHints = [[ThingUIHints alloc] init]; uiHints.iconUri = @\"/Content/VirtualGateway/img/icon-thing-slider.png\"; [[NodeController sharedNodeController] addThing:[[Thing alloc] initWithThingKey:[thingKey toString] name:[deviceName stringByAppendingString:thingUID] config:nil ports:ports type:@\"iOSVirtual\" blockType:@\"\" uiHints:uiHints]]; } // Virtual text input { NSString *thingUID = @\"iOSTextInput\"; ThingKey *thingKey = [[ThingKey alloc] initWithNodeKey:nodeKey andThingUid:thingUID]; Port *port = [[Port alloc] init]; port.name = @\"Text\"; port.ioDirection = EnumIOPortDirection_Output; port.type = EnumPortType_String; port.portKey = [[[PortKey alloc] initWithThingKey:thingKey andPortUid:@\"0\"] toString]; NSMutableArray *ports = (id)[NSMutableArray new]; [ports addObject:port]; ThingUIHints *uiHints = [[ThingUIHints alloc] init]; uiHints.iconUri = @\"/Content/VirtualGateway/img/icon-thing-text.png\"; [[NodeController sharedNodeController] addThing:[[Thing alloc] initWithThingKey:[thingKey toString] name:[deviceName stringByAppendingString:thingUID] config:nil ports:ports type:@\"iOSVirtual\" blockType:@\"\" uiHints:uiHints]]; }     "
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/rest/",
	"title": "Rest API",
	"tags": [],
	"description": "Quick overview and guides to get you started with our Plegma API and framework and help you create Things that can access the Yodiwo IoT Cloud Services. Hopefully you&#39;ll be up and running soon!.",
	"content": "Quick overview and guides to get you started with our Plegma API and framework and help you create Things that can access the Yodiwo IoT Cloud Services. Hopefully you\u0026rsquo;ll be up and running soon!.\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/rest/rest-api-events/",
	"title": "Post events",
	"tags": [],
	"description": "",
	"content": " Definition https://api.yodiwo.com/api/1.0/NODEKEY/SECRETKEY/porteventmsg\nParameters    Name Type     nodekey  required string n/a  NodeKey (received during Node pairing)   secretkey  required string n/a  SecretKey (received during Node pairing)    Examples C#.    public void PostRestMsg(Tupletarget_msg) { try { //add base route string worker = \"https://\" + ActiveCfg.RestServer + \":443/api/\"; //add API ver worker += \"v1.0/\"; //add nodekey worker += ActiveCfg.nodeKey + \"/\"; //add secretkey worker += ActiveCfg.nodeSecret + \"/\"; //add msg name worker += target_msg.Item1; var client = new HttpClient(); client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\")); var task = client.PostAsync(worker, new StringContent(target_msg.Item2, Encoding.UTF8, \"application/json\")); task.Wait(); HttpResponseMessage rsp = task.Result; if (rsp.StatusCode == System.Net.HttpStatusCode.OK) { Console.WriteLine(\"All ok!\"); } } catch {} }     Result Format  200 OK.   400 Bad Request.   401 Unauthorized·   Accepted Generic error in handling message Authorization failed (e.g. invalid keys or ApiKey does not match NodeKey)   Documentation Posts a new trigger to the cloud server. The message contains an array of port events that the cloud server should act on. Look into API event passing for more info.\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/messages/things-mgmt-ctrl/",
	"title": "Things management &amp; control",
	"tags": [],
	"description": "",
	"content": " The main way for Nodes and the Cloud to exchange information about Nodes\u0026rsquo; Things are the Things Get/Set messages\nTHINGS GET A Things Get request can be used by either the Cloud or Nodes to request information from the receiver. Its contents are:\nC#.  Java.  C·  Objective-C    public class ThingsGet : ApiMsg { public eThingsOperation Operation; public string ThingKey public int RevNum; public ThingsGet() : base() { } }    package com.yodiwo.plegma; import java.util.ArrayList; public class ThingsGet extends ApiMsg { public eThingsOperation Operation; public String ThingKey; public int RevNum; public ThingsSet() { } }    typedef struct Yodiwo_Plegma_ThingsGet { int32_t SeqNo; Yodiwo_Plegma_eThingsOperation Operation; char* ThingKey; int RevNum; } Yodiwo_Plegma_ThingsGet_t;    @interface ThingsGet : APIMsg @property (nonatomic) EnumThingsOperation operation; @property (strong, nonatomic) NSString\u0026lt;Optional\u0026gt; *thingKey; @property (strong, nonatomic) NSInteger revNum; @end     Any endpoint can send this message at any time to request any Things-related update from the other end. The message contains:\n Operation: a field that specifies what this request is about)\n ThingKey: (optional) ThingKey of Thing that this Request refers to. If null, missing or empty, then the Request refers to all of the receiver\u0026rsquo;s Things (obviously if the Cloud is the receiver, \u0026ldquo;all\u0026rdquo; refers to the Node only)\n RevNum: Sender\u0026rsquo;s revision number of Things update/sync state. An integer number that represents each end\u0026rsquo;s view of Things and gets incremented with every change. Nodes and Cloud can use this number to avoid constantly syncing Things with each other\n  THINGS SET The ThingsSet message is either a response to a ThingsGet message, or a new message that must be handled by the receiver. In both case it must follow the previously mentioned conventions about blocking messages. If it initiates a new action, then it expects a GenericRsp message as a response. Otherwise it itself is a response to a previous ThingsGet message.\nC#.  Java.  C·  Objective-C    public class ThingsSet : ApiMsg { public eThingsOperation Operation; public bool Status; public Thing[] Data; public int RevNum; public ThingsSet() : base() { } }    package com.yodiwo.plegma; import java.util.ArrayList; public class ThingsSet extends ApiMsg { public eThingsOperation Operation; public Boolean Status; public ArrayList Data; public int RevNum; public ThingsSet() { } }    typedef struct Yodiwo_Plegma_ThingsSet { int32_t SeqNo; Yodiwo_Plegma_eThingsOperation Operation; bool_t Status; Array_Yodiwo_Plegma_Thing_t Data; int RevNum; } Yodiwo_Plegma_ThingsSet_t;    @interface ThingsSet : APIMsg @property (nonatomic) EnumThingsOperation Operation; @property (nonatomic) BOOL Status; @property (strong, nonatomic) NSMutableArray\u0026lt;Thing,Optional\u0026gt; *Data; // of Thing @property (strong, nonatomic) NSInteger revNum; @end     The message\u0026rsquo;s fields are:\n Operation: Operation that specifies how the array of Things that the message contains is to be interpreted; see below for more info\n Status: specifies whether the parsing of the request was successful and hence this message contains valid data\n Data: array of Things (and hence of their Ports as well) that that are relevant to the selected operation.\n RevNum: Sender\u0026rsquo;s revision number of Things update/sync state. An integer number that represents each end\u0026rsquo;s view of Things and gets incremented with every change. Nodes and Cloud can use this number to avoid constantly syncing Things with each other\n  THINGS OPERATIONS Possible Things Operations are the following:\n Update (1): (Things SET only) referenced Thing(s) in the Data array field are to be updated at the receiver. If they don\u0026rsquo;t already exist, they should be created. Use the Update Operation id to add new Things or to update Configuration parameters of existing ones (see callout below)\n Overwrite (2): (Things SET only) referenced Thing(s) are to be updated at endpoint if they exist, created if not. Previously existing things at endpoint that are not in this message are deleted. Basically a wholesale \u0026ldquo;here\u0026rsquo;s the new state\u0026rdquo; message\n Delete (3): (Things SET only) ask that the endpoint deletes referenced Thing(s)\n Get (4): (Things GET only) the receiving endpoint must respond with its Thing(s) in the Data array of its response. This message can refer either to a single Thing (via the Request\u0026rsquo;s ThingKey), or to all of the receiving endpoint\u0026rsquo;s Things (empty ThingKey)\n Scan (5): (Things GET only) ask that the receiver actively scans for new things and sends back results as its response\n Sync (6): (Get and Set) sync Thing revision numbers between sender and receiver. Any data in the Things array will be ignored\n  For operations Get and Scan, the responding device is free to choose the proper Operation id for its response (Update to add a few new Things, or Overwrite to send a new full suite of Things)\n\u0026ensp;Updating Things\u0026rsquo; configuration parameters The cloud side will also set new configuration values this way, i.e. it will send a ThingsSet message with updated contents of Thing.Config[] fields and the Node is expected to parse them and update its internal configuration accordingly, as well as reply with a GenericRsp\nHowever if you're using the existing Yodiwo Agents (iOS, Java) or helper libraries (C#) you shouldn't have to worry about this, as they handle such scenarios and call the callbacks that you provide  "
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/mqtt/",
	"title": "MQTT",
	"tags": [],
	"description": "Quick overview and guides to get you started with our Plegma API and framework and help you create Things that can access the Yodiwo IoT Cloud Services. Hopefully you&#39;ll be up and running soon!.",
	"content": "Quick overview and guides to get you started with our Plegma API and framework and help you create Things that can access the Yodiwo IoT Cloud Services. Hopefully you\u0026rsquo;ll be up and running soon!\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/messages/message-event-passing/",
	"title": "Message &amp; event passing",
	"tags": [],
	"description": "",
	"content": " All event exchanges, i.e. asynchronous triggers, calls to action, state updates, etc, between Nodes and the Cloud exclusively happen through the PortEventMsg API message:\nPORTEVENTMSG C#.  Java.  C·  Objective-C    public class PortEventMsg : ApiMsg { public PortEvent[] PortEvents; public PortEventMsg() : base() { } }    package com.yodiwo.plegma; public class PortEventMsg extends ApiMsg { public PortEvent[] PortEvents; public PortEventMsg() { } }    typedef struct Yodiwo_Plegma_PortEventMsg { int32_t SeqNo; Array_Yodiwo_Plegma_PortEvent_t PortEvents; } Yodiwo_Plegma_PortEventMsg_t; typedef struct Array_Yodiwo_Plegma_PortEvent { int num; struct Yodiwo_Plegma_PortEvent* elems; } Array_Yodiwo_Plegma_PortEvent_t; } Yodiwo_Plegma_ThingsSet_t;    @interface PortEventMsg : APIMsg @property (strong, nonatomic) NSMutableArray\u0026lt;PortEvent\u0026gt; *PortEvents; @end     Each message contains an array of simple PortEvent entries:\nC#.  Java.  C·  Objective-C    public class PortEvent { public string PortKey; public string State; public uint RevNum; public ulong Timestamp; }    public class PortEvent { public String PortKey; public String State; public int RevNum; public long Timestamp; }    typedef struct Yodiwo_Plegma_PortEvent { char* PortKey; char* State; uint32_t RevNum; uint64_t Timestamp; } Yodiwo_Plegma_PortEvent_t;    @interface PortEvent : JSONModel @property (strong, nonatomic) NSString *PortKey; @property (strong, nonatomic) NSString\u0026lt;Optional^gt; *State; @property (nonatomic) NSUInteger RevNum; @property (nonatomic) NSUInteger Timestamp; @end      PortKey: the key to identify which Port (in which Thing of which Node) this event refers to State: the message of event, encoded as a string, as discussed here RevNum: revision number of this update. If non-zero duplicate rejection can be performed. For the cloud servers, if this is zero, all events are treated as valid Timestamp: event\u0026rsquo;s timestamp in milliseconds since Unix epoch. For the cloud servers, if this is zero, the time at reception is stamped  \u0026ensp;Port Events for inactive ports To aid power consumption on the Node side, and also save channel bandwidth, it is advised that Nodes do not send Port Event messages for Ports that are inactive.\nSee below at ActivePortKeys for what active/inactive means, and how to check  Synchronising states between Nodes and the Cloud In the case where states of Ports between the Cloud and Nodes get out-of-sync, some tools are offered to rectify this, in the form of Port State messages. These messages exchange similar information about states as Port Events but do not trigger any action on the receiver apart from an update of their internal house-keeping.\nPORTSTATEREQ This Request is sent from either the Node or the Cloud Server to ask for an update, according to the message\u0026rsquo;s Operation field. The receiving end must respond with a PortStateRsp in an RPC-compliant way.\nC#.  Java.  C·  Objective-C    public class PortStateReq : ApiMsg { public ePortStateOperation Operation; public string[] PortKeys; public PortStateRsp() : base() { this.Id = eApiType.PortStateReq; } }    package com.yodiwo.plegma; import java.util.ArrayList; public class PortStateReq extends ApiMsg { public ePortStateOperation Operation; public String[] PortKeys; public PortStateReq() { this.Id = eApiType.PortStateReq; } }    typedef struct Yodiwo_Plegma_PortStateReq { //[ApiMsg] Yodiwo_Plegma_eApiType Id; int32_t Version; int32_t SeqNo; int32_t ResponseToSeqNo; Yodiwo_Plegma_ePortStateOperation Operation; Array_char* PortKeys; } Yodiwo_Plegma_PortStateReq_t;    @interface ThingsReq : APIMsg @property (nonatomic) EnumThingsOperation Operation; @property (strong, nonatomic) NSString\u0026lt;Optional\u0026gt; *ThingKey; @property (strong, nonatomic) NSMutableArray\u0026lt;Thing, Optional\u0026gt; *Data; // of Thing @end      Operation: the Type of operation requested. Can be one of: enum ePortStateOperation { SpecificKeys = 1, //get states for the PortKeys specified in this msg\u0026rsquo;s Keys array ActivePortStates = 2, //get current states only for currently deployed Ports AllPortStates = 3, //get current states for all ports of this Node } PortKeys: Array of PortKeys that the server should send an update for (to be used in conjuction with ePortStateOperation.SpecificKeys. Must be set if Operation is set to SpecificKeys, shall be ignored otherwise.  PORTSTATERSP This message is the response to the previous PortStateReq message. As always, the message\u0026rsquo;s ResponseToSeqNo will be set to the original request\u0026rsquo;s SeqNo\nIn detail the message is:\nC#.  Java.  C·  Objective-C    public class PortStateRsp : ApiMsg { public ePortStateOperation Operation; public PortState[] PortStates; public PortStateRsp() : base() { this.Id = eApiType.PortStateRsp; } }    package com.yodiwo.plegma; import java.util.ArrayList; public class PortStateRsp extends ApiMsg { public ePortStateOperation Operation; public PortState[] PortStates; public PortStateRsp() { this.Id = eApiType.PortStateRsp; } }    typedef struct Yodiwo_Plegma_PortStateRsp { //[ApiMsg] Yodiwo_Plegma_eApiType Id; int32_t Version; int32_t SeqNo; int32_t ResponseToSeqNo; Yodiwo_Plegma_ePortStateOperation Operation; Array_Yodiwo_Plegma_PortState_t PortStates; } Yodiwo_Plegma_PortStateRsp_t; typedef struct Array_Yodiwo_Plegma_PortState { int num; struct Yodiwo_Plegma_PortState* elems; } Array_Yodiwo_Plegma_PortState_t;    @interface PortStateRsp : APIMsg @property (nonatomic) EnumStateOperation Operation; @property (strong, nonatomic) NSMutableArray\u0026lt;PortState\u0026gt; *PortStates; @end     The message\u0026rsquo;s fields are:\n Operation: Type of operation requested and this message is responding to. The type will affect which of the two other fields is populated with data\n PortStates: Array of requested Port states\n  \u0026ensp;\u0026lsquo;Active\u0026rsquo; Port A port is considered active when:its parent Thing is placed in at least one Graph that is currently deployed (not just saved) the port itself is actually connected to another block's port  As expected, the PortState class is very similar to the previously described PortEvent class, with a simple addition:\nC#.  Java.  C·  Objective-C    public class PortState { public string PortKey; public string State; public int RevNum; public bool IsDeployed; //\u0026lt;-- this one! }    package com.yodiwo.plegma; import java.util.ArrayList; public class PortState { public String PortKey; public String State; public int RevNum; public Boolean IsDeployed; //this one }    typedef struct Yodiwo_Plegma_PortState { char* PortKey; char* State; int32_t RevNum; bool_t IsDeployed; //this one } Yodiwo_Plegma_PortState_t;    @interface PortState : JSONModel @property (strong, nonatomic) NSString *PortKey; @property (strong, nonatomic) NSString\u0026lt;Optional\u0026gt; *State; @property (nonatomic) NSInteger RevNum; @property (nonatomic) BOOL IsDeployed; //this one @end     The extra field IsDeployed specifies whether the referenced port is currently active and connected in deployed graphs.\nThe rest of the field convey the same information as in a Port Event, but without acting/triggering any actions on this data.\nACTIVEPORTKEYSMSG This message is an asynchronous message from the Cloud to a Node to inform the latter of which Ports are currently active. This usually happens because the user deployed or undeployed a graph (hence adding/removing Things or changing Port connections) through the Cyan environment.\nThe contents of the message are extremely simple, as the Node is expected to simply discard its old set of active PortKey values and replace it with the one specified by this message:\nC#.  Java.  C·  Objective-C    public class ActivePortKeysMsg : ApiMsg { public String[] ActivePortKeys; public ActivePortKeysMsg() : base() { this.Id = eApiType.ActivePortKeysMsg; } }    package com.yodiwo.plegma; import java.util.ArrayList; public class ActivePortKeysMsg extends ApiMsg { public String[] ActivePortKeys; public ActivePortKeysMsg() { this.Id = eApiType.ActivePortKeysMsg; } }    typedef struct Yodiwo_Plegma_ActivePortKeysMsg { Yodiwo_Plegma_eApiType Id; int32_t Version; int32_t SeqNo; int32_t ResponseToSeqNo; Array_char* ActivePortKeys; } Yodiwo_Plegma_ActivePortKeysMsg_t;    @interface ActivePortKeysMsg : APIMsg @property (strong, nonatomic) NSMutableArray\u0026lt;Optional\u0026gt; *ActivePortKeys; @end     Nodes are expected to keep track of, and only send events for those Ports that are currently active, thus reducing power consumption on the node and traffic on the medium.\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/rest/rest-api-port-states-request/",
	"title": "Sync with server&#39;s Port States",
	"tags": [],
	"description": "",
	"content": " Definition https://api.yodiwo.com/api/1.0/NODEKEY/SECRETKEY/portstatereq\nParameters    Name Type     nodekey  required string n/a  NodeKey (received during Node pairing)   secretkey  required string n/a  SecretKey (received during Node pairing)    Documentation Sends a Port States request to the cloud server. Route parameters include the Node and Secret keys received during the Node\u0026rsquo;s pairing. The body of the message is expected to be a JSON-serialized message of the PortStateReq class.\nThe server will reply with a Port States Response.\nFor more information check out State synchronization\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/apis/plegma/websockets-overview/",
	"title": "Web Sockets Overview",
	"tags": [],
	"description": "",
	"content": "You can also interface with our cloud servers via Web Sockets. All previous conventions about messaging with the Plegma API also stand here. The wrapper class that carries all Websocket messages is the following:\n[any language].   public class WebSocketMsg { public eWSAPIType Id; public string Subid; public eMsgFlags Flags; public int SyncId; public string Payload; }    Id: this field distinguishes between initial Pairing messages (which follow the logic described in Pairing) and API messages. This is needed since unlike the rest of the supported protocols where HTTPS is used for the pairing procedure, here it is also carried out over Websockets\npublic enum eWSAPIType { Pairing = 1, Api = 2 }  Subid: a string that specifies the type of message being sent\n Flags: this field distinguishes between:\n Request-type messages (Get or Req) that mandate a response (Rsp or Set) Response-type messages to previous requests simple asynchronous messages Specifically Flags is:\npublic enum eMsgFlags { None = 0, //async message Request = 1, //message is request and expects response Response = 2 //message is response to previous request }   SyncId:\n for a request that expects a response, this must be set to a non-zero, monotonically increasing number for a message that is a response to a previous request (Req or Get), this must be set to the original message\u0026rsquo;s SyncId as previously described. for an async message the field should be ignored  Payload: json-serialized payload being sent (same as in Mqtt msg format)\n  "
},
{
	"uri": "https://docs.yodiwo.com/doc/snippets/",
	"title": "Snippets",
	"tags": [],
	"description": "",
	"content": " Blue A notice disclaimer\n   Show source code   {{% notice note %}} A notice disclaimer {{% /notice %}}   \nthis is a text   Show source code   {{% alert info %}}**this** is a text{{% /alert %}}   \n  API reference:  The complete up-to-date API reference in doxygen format can be found here\n   panel title this is a panel text    Show source code   {{% panel theme=\u0026quot;info\u0026quot; header=\u0026quot;panel title\u0026quot; %}}this is a panel text{{% /panel %}}   \n\u0026ensp;API Reference The complete up-to-date API reference in doxygen format can be found here    Show source code   {{% fa-panel theme=\u0026quot;info\u0026quot; header=\u0026quot;API Reference\u0026quot; icon=\u0026quot;fa-info-circle\u0026quot; %}}The complete up-to-date API reference in doxygen format can be found [here](https://yodiwo.github.io/plegma/Plegma/Doxygen){{% /fa-panel %}}    Orange An information disclaimer\n   show source code   {{% notice info %}} An information disclaimer {{% /notice %}}   \nBe carefull is a text   show source code   {{% alert warning %}}**Be carefull** is a text{{% /alert %}}    panel title this is a panel text    show source code   {{% panel theme=\u0026quot;warning\u0026quot; header=\u0026quot;panel title\u0026quot; %}}this is a panel text{{% /panel %}}   \n\u0026ensp;panel title Again, this is a panel text    show source code   {{% fa-panel theme=\u0026quot;warning\u0026quot; header=\u0026quot;panel title\u0026quot; icon=\u0026quot;fa-exclamation-circle\u0026quot; %}}Again, this is a panel text{{% /fa-panel %}}    Green A tip disclaimer\n   show source code   {{% notice tip %}} A tip disclaimer {{% /notice %}}   \nYeahhh ! is a text   show source code   {{% alert success %}}Yeahhh ! is a text{{% /alert %}}      we come bearing gifts  Look for our Github page to download fully functional code examples of Node implementations in various popular languages!\n   panel title this is a panel text    show source code   {{% panel theme=\u0026quot;success\u0026quot; header=\u0026quot;panel title\u0026quot; %}}this is a panel text{{% /panel %}}   \n\u0026ensp;panel title Again, this is a panel text    show source code   {{% fa-panel theme=\u0026quot;success\u0026quot; header=\u0026quot;panel title\u0026quot; icon=\u0026quot;fa-check-circle\u0026quot; %}}Again, this is a panel text{{% /fa-panel %}}    Red An warning disclaimer\n   show source code   {{% notice warning %}} An warning disclaimer {{% /notice %}}   \nBeware ! is a text   show source code   {{% alert theme=\u0026quot;danger\u0026quot; %}}Beware ! is a text{{% /alert %}}   \npanel title this is a panel text    show source code   {{% panel theme=\u0026quot;danger\u0026quot; header=\u0026quot;panel title\u0026quot; %}}this is a panel text{{% /panel %}}   \n\u0026ensp;panel title Again, this is a panel text    show source code   {{% fa-panel theme=\u0026quot;danger\u0026quot; header=\u0026quot;panel title\u0026quot; icon=\u0026quot;fa-exclamation-triangle\u0026quot; %}}Again, this is a panel text{{% /fa-panel %}}    Other boxes this is a panel text    show source code   {{% panel %}} this is a panel text {{% /panel %}}    panel title this is a panel text    show source code   {{% panel theme=\u0026quot;default\u0026quot; header=\u0026quot;panel title\u0026quot; %}} this is a panel text {{% /panel %}}   \npanel title this is a panel text    show source code   {{% panel theme=\u0026quot;primary\u0026quot; header=\u0026quot;panel title\u0026quot; %}} this is a panel text {{% /panel %}}   \nthis is a panel text panel title    show source code   {{% panel theme=\u0026quot;default\u0026quot; footer=\u0026quot;panel title\u0026quot; %}}this is a panel text{{% /panel %}}   \nthis is a panel text panel title    show source code   {{% panel theme=\u0026quot;primary\u0026quot; footer=\u0026quot;panel title\u0026quot; %}} this is a panel text {{% /panel %}}   \n\u0026ensp;panel title Again, this is a panel text    show source code   {{% fa-panel theme=\u0026quot;primary\u0026quot; header=\u0026quot;panel title\u0026quot; icon=\u0026quot;fa-magic\u0026quot; %}}Again, this is a panel text{{% /fa-panel %}}   \nAgain, this is a panel text \u0026ensp;panel title    show source code   {{% fa-panel theme=\u0026quot;primary\u0026quot; footer=\u0026quot;panel title\u0026quot; icon=\u0026quot;fa-magic\u0026quot; %}}Again, this is a panel text{{% /fa-panel %}}   \n"
},
{
	"uri": "https://docs.yodiwo.com/doc/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Contact us at : info@yodiwo.com \n\n\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "\n"
},
{
	"uri": "https://docs.yodiwo.com/doc/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.yodiwo.com/doc/categories/cyan/",
	"title": "Cyan",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.yodiwo.com/doc/categories/plegma/",
	"title": "Plegma",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.yodiwo.com/doc/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.yodiwo.com/doc/categories/wisper/",
	"title": "Wisper",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.yodiwo.com/doc/",
	"title": "homepage",
	"tags": [],
	"description": "",
	"content": "\n\n\nPlatform Platform overview\n  Interconnection Concepts and Topology     APIs     Yodiwo Fog Gateway     \n\n\nWisper Wisper family of edge gateways\n  Yodiwo Wisper     Wisper Families  \n Wisper Pro   \n\n\n\nAPIsAPIs reference and walkthroughs\n  Plegma    Getting Started   Pairing Overview   API Messages   Rest API   MQTT   Web Sockets Overview    \n\n\nIntegratorsIntegrator\u0026rsquo;s Guide\n  Direct Connection to Alcyone    Using RESTful HTTP requests     Using 3rd party MQTT brokers    \n Via the Plegma API  \n Plegma Nodes Credentials   \n Plegma Things Creation and Handling     \n\n \n\n"
}]